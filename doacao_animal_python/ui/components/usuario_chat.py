# Code generated by TkForge <https://github.com/axorax/tkforge>
# Donate to support TkForge! <https://www.patreon.com/axorax>

import os
import sys
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from datetime import datetime as dt

# Make imports work when running the file directly
project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from DAO.chat_dao import ChatDAO
from exceptions.custom_exception import CustomException


class UsuarioChat(tk.Frame):
    """Simple chat UI that works for either Adotante or Protetor.
    It uses ChatDAO to send messages and to load conversation history.

    Usage: run `python ui/usuario_chat.py` and fill the IDs for sender/receiver.
    """

    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller

        # Estilos padronizados com o login
        style = ttk.Style(self)
        style.theme_use('clam')
        style.configure('Card.TFrame', background='#E9ECEF')
        style.configure('Heading.TLabel', background='#E9ECEF', font=('Segoe UI', 20, 'bold'), foreground='#222')
        style.configure('Label.TLabel', background='#E9ECEF', font=('Segoe UI', 12), foreground='#111')
        style.configure('TEntry', padding=6)
        style.configure('Accent.TButton', background="#4B6EF6", foreground='white', font=('Segoe UI', 12, 'bold'))
        style.map('Accent.TButton',
              background=[('active', '#3751c8'), ('pressed', '#2d43a6'), ('!active', '#4B6EF6')],
              foreground=[('disabled', '#bdbdbd'), ('!disabled', 'white')])

        # Header / controls
        header = ttk.Frame(self, style='Card.TFrame')
        header.pack(fill=tk.X, padx=24, pady=(20, 4))

        ttk.Label(header, text="Remetente ID:", style='Label.TLabel').grid(row=0, column=0, sticky='w')
        self.entry_sender = ttk.Entry(header, width=8)
        self.entry_sender.grid(row=0, column=1, padx=(4, 12))

        ttk.Label(header, text="Destinatário ID:", style='Label.TLabel').grid(row=0, column=2, sticky='w')
        self.entry_dest = ttk.Entry(header, width=8)
        self.entry_dest.grid(row=0, column=3, padx=(4, 12))

        ttk.Label(header, text="Tipo Remetente:", style='Label.TLabel').grid(row=0, column=4, sticky='w')
        self.combo_tipo_rem = ttk.Combobox(header, values=["Adotante", "Protetor"], width=10, state='readonly')
        self.combo_tipo_rem.current(0)
        self.combo_tipo_rem.grid(row=0, column=5, padx=(4, 12))

        ttk.Label(header, text="Tipo Destinatário:", style='Label.TLabel').grid(row=0, column=6, sticky='w')
        self.combo_tipo_dest = ttk.Combobox(header, values=["Adotante", "Protetor"], width=10, state='readonly')
        self.combo_tipo_dest.current(1)
        self.combo_tipo_dest.grid(row=0, column=7, padx=(4, 12))

        ttk.Label(header, text="ID Processo:", style='Label.TLabel').grid(row=0, column=8, sticky='w')
        self.entry_id_processo = ttk.Entry(header, width=8)
        self.entry_id_processo.grid(row=0, column=9, padx=(4, 12))

        self.btn_load = ttk.Button(header, text="Carregar conversa", style='Accent.TButton', command=self.load_conversation)
        self.btn_load.grid(row=0, column=10, padx=(6, 0))

        # Main chat area: scrollable canvas with message frames (for bubble layout)
        body = ttk.Frame(self, style='Card.TFrame')
        # Use grid inside this frame so the canvas can expand vertically and horizontally
        body.pack(fill=tk.BOTH, expand=True, padx=24, pady=(4, 20))
        body.grid_rowconfigure(0, weight=1)
        body.grid_columnconfigure(0, weight=1)

        # Styles for bubbles (ajustados para combinar)
        style.configure('Sent.TLabel', background='#D6E9FF', foreground='#072b68', padding=8, font=('Segoe UI', 10))
        style.configure('Recv.TLabel', background='#F3F4F6', foreground='#111', padding=8, font=('Segoe UI', 10))
        style.configure('Timestamp.TLabel', background='#E9ECEF', foreground='#666', font=('Segoe UI', 8))

        self.canvas = tk.Canvas(body, borderwidth=0, highlightthickness=0, background='#E9ECEF')
        self.scrollbar = ttk.Scrollbar(body, orient='vertical', command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        # place with grid so it expands properly
        self.canvas.grid(row=0, column=0, sticky='nsew')
        self.scrollbar.grid(row=0, column=1, sticky='ns')

        self.messages_frame = ttk.Frame(self.canvas, style='Card.TFrame')
        self.canvas.create_window((0, 0), window=self.messages_frame, anchor='nw')

        self.messages_frame.bind('<Configure>', lambda e: self.canvas.configure(scrollregion=self.canvas.bbox('all')))

        # Allow mousewheel scrolling when pointer is over the canvas
        def _on_mousewheel(event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), 'units')
        self.canvas.bind_all('<MouseWheel>', _on_mousewheel)

        # Keep a small cache of displayed messages if needed
        self._displayed_messages = []

        # Composer
        composer = ttk.Frame(self, style='Card.TFrame')
        composer.pack(fill=tk.X, padx=24, pady=(0, 20))
        composer.grid_columnconfigure(0, weight=1)

        self.entry_message = ttk.Entry(composer, font=("Segoe UI", 12))
        self.entry_message.grid(row=0, column=0, sticky='ew', padx=(0, 8), pady=6)

        self.btn_send = ttk.Button(composer, text="Enviar", style='Accent.TButton', command=self.on_send)
        self.btn_send.grid(row=0, column=1)
        
        self.btn_back = ttk.Button(composer, text="Voltar", style='Accent.TButton', command=self.on_back)
        self.btn_back.grid(row=0, column=2)

        # Polling flag
        self._polling = False

    def append_history(self, text: str):
        # Legacy: append plain text line (kept for compatibility)
        self.txt_history_insert_plain(text)

    def txt_history_insert_plain(self, text: str):
        # Fallback logger -> still add as a small label at the bottom
        lbl = ttk.Label(self.messages_frame, text=text, style='Recv.TLabel', wraplength=480, justify='left')
        lbl.pack(fill=tk.X, padx=8, pady=4, anchor='w')
        self.canvas.yview_moveto(1.0)

    def display_messages(self, messages, my_id: int):
        # Clear existing
        for child in self.messages_frame.winfo_children():
            child.destroy()
        for m in messages:
            try:
                is_sent = (m.idRemetente == my_id)
            except Exception:
                is_sent = False
            self._create_message_widget(m, is_sent)
        self.canvas.update_idletasks()
        self.canvas.yview_moveto(1.0)

    def _create_message_widget(self, m, is_sent: bool):
        # container frame for each message
        container = ttk.Frame(self.messages_frame, style='Card.TFrame')
        container.pack(fill=tk.X, pady=6, padx=6)

        wrap = 420
        # bubble
        bubble_style = 'Sent.TLabel' if is_sent else 'Recv.TLabel'
        bubble = ttk.Label(container, text=m.conteudo, style=bubble_style, wraplength=wrap, anchor='w', justify='left')

        ts_text = ''
        if hasattr(m, 'dataMensagem') and m.dataMensagem:
            ts = m.dataMensagem
            try:
                ts_text = ts.strftime('%Y-%m-%d %H:%M')
            except Exception:
                ts_text = str(ts)

        ts_lbl = ttk.Label(container, text=ts_text, style='Timestamp.TLabel')

        if is_sent:
            bubble.pack(side=tk.RIGHT, anchor='e', padx=(60, 6))
            ts_lbl.pack(side=tk.RIGHT, anchor='e', padx=(60, 6), pady=(2, 0))
        else:
            bubble.pack(side=tk.LEFT, anchor='w', padx=(6, 60))
            ts_lbl.pack(side=tk.LEFT, anchor='w', padx=(6, 60), pady=(2, 0))

    def load_conversation(self):
        try:
            id_sender = int(self.entry_sender.get())
            id_dest = int(self.entry_dest.get())
        except ValueError:
            messagebox.showwarning("IDs inválidos", "Informe IDs numéricos para remetente e destinatário.")
            return

        try:
            # optional process id filter
            id_processo = None
            pid = self.entry_id_processo.get().strip()
            if pid:
                try:
                    id_processo = int(pid)
                except ValueError:
                    messagebox.showwarning("ID Processo inválido", "Informe um ID de processo numérico ou deixe em branco.")
                    return

            conv = ChatDAO.get_conversation(id_sender, id_dest, id_processo)
            self.display_messages(conv, id_sender)
        except CustomException as e:
            messagebox.showerror("Erro", f"Erro ao carregar conversa: {e}")

    def on_send(self):
        try:
            id_sender = int(self.entry_sender.get())
            id_dest = int(self.entry_dest.get())
        except ValueError:
            messagebox.showwarning("IDs inválidos", "Informe IDs numéricos para remetente e destinatário.")
            return

        conteudo = self.entry_message.get().strip()
        if not conteudo:
            return

        tipo_rem = self.combo_tipo_rem.get()
        tipo_dest = self.combo_tipo_dest.get()

        try:
            id_processo = None
            pid = self.entry_id_processo.get().strip()
            if pid:
                try:
                    id_processo = int(pid)
                except ValueError:
                    messagebox.showwarning("ID Processo inválido", "Informe um ID de processo numérico ou deixe em branco.")
                    return

            ChatDAO.send_message(id_sender, id_dest, conteudo, tipo_remetente=tipo_rem, tipo_destinatario=tipo_dest, id_processo=id_processo)
            self.entry_message.delete(0, tk.END)
            self.load_conversation()
        except CustomException as e:
            messagebox.showerror("Erro ao enviar", f"Erro ao enviar mensagem: {e}")
    
    def on_back(self):
        messagebox.showinfo("Voltar", "Voltando para tela anterior")
        if self.controller:
            self.controller.show_frame("Welcome")
        



