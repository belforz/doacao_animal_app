# Code generated by TkForge <https://github.com/axorax/tkforge>
# Donate to support TkForge! <https://www.patreon.com/axorax>

import os
import sys
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from datetime import datetime as dt

# Make imports work when running the file directly
project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from DAO.chat_dao import ChatDAO
from exceptions.custom_exception import CustomException


class UsuarioChat(tk.Tk):
    """Simple chat UI that works for either Adotante or Protetor.
    It uses ChatDAO to send messages and to load conversation history.

    Usage: run `python ui/usuario_chat.py` and fill the IDs for sender/receiver.
    """

    def __init__(self):
        super().__init__()
        self.title("Chat")
        self.geometry("800x520")
        self.resizable(True, True)

        # Header / controls
        header = ttk.Frame(self)
        header.pack(fill=tk.X, padx=12, pady=(8, 4))

        ttk.Label(header, text="Remetente ID:").grid(row=0, column=0, sticky='w')
        self.entry_sender = ttk.Entry(header, width=8)
        self.entry_sender.grid(row=0, column=1, padx=(4, 12))

        ttk.Label(header, text="Destinatário ID:").grid(row=0, column=2, sticky='w')
        self.entry_dest = ttk.Entry(header, width=8)
        self.entry_dest.grid(row=0, column=3, padx=(4, 12))

        ttk.Label(header, text="Tipo Remetente:").grid(row=0, column=4, sticky='w')
        self.combo_tipo_rem = ttk.Combobox(header, values=["Adotante", "Protetor"], width=10, state='readonly')
        self.combo_tipo_rem.current(0)
        self.combo_tipo_rem.grid(row=0, column=5, padx=(4, 12))

        ttk.Label(header, text="Tipo Dest:").grid(row=0, column=6, sticky='w')
        self.combo_tipo_dest = ttk.Combobox(header, values=["Adotante", "Protetor"], width=10, state='readonly')
        self.combo_tipo_dest.current(1)
        self.combo_tipo_dest.grid(row=0, column=7, padx=(4, 12))

        self.btn_load = ttk.Button(header, text="Carregar conversa", command=self.load_conversation)
        self.btn_load.grid(row=0, column=8, padx=(6, 0))

        # Main chat area: scrollable canvas with message frames (for bubble layout)
        body = ttk.Frame(self)
        body.pack(fill=tk.BOTH, expand=True, padx=12, pady=(4, 8))

        # Styles for bubbles
        style = ttk.Style(self)
        style.configure('Sent.TLabel', background='#D6E9FF', foreground='#072b68', padding=8, font=('Segoe UI', 10))
        style.configure('Recv.TLabel', background='#F3F4F6', foreground='#111', padding=8, font=('Segoe UI', 10))
        style.configure('Timestamp.TLabel', background='#E9ECEF', foreground='#666', font=('Segoe UI', 8))

        self.canvas = tk.Canvas(body, borderwidth=0, highlightthickness=0, background='#E9ECEF')
        self.scrollbar = ttk.Scrollbar(body, orient='vertical', command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.messages_frame = ttk.Frame(self.canvas, style='Card.TFrame')
        self.canvas.create_window((0, 0), window=self.messages_frame, anchor='nw')

        self.messages_frame.bind('<Configure>', lambda e: self.canvas.configure(scrollregion=self.canvas.bbox('all')))

        # Allow mousewheel scrolling when pointer is over the canvas
        def _on_mousewheel(event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), 'units')
        self.canvas.bind_all('<MouseWheel>', _on_mousewheel)

        # Keep a small cache of displayed messages if needed
        self._displayed_messages = []

        # Composer
        composer = ttk.Frame(self)
        composer.pack(fill=tk.X, padx=12, pady=(0, 12))

        self.entry_message = ttk.Entry(composer, font=("Segoe UI", 11))
        self.entry_message.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 8))

        self.btn_send = ttk.Button(composer, text="Enviar", command=self.on_send)
        self.btn_send.pack(side=tk.RIGHT)

        # Polling flag
        self._polling = False

    def append_history(self, text: str):
        # Legacy: append plain text line (kept for compatibility)
        self.txt_history_insert_plain(text)

    def txt_history_insert_plain(self, text: str):
        # Fallback logger -> still add as a small label at the bottom
        lbl = ttk.Label(self.messages_frame, text=text, style='Recv.TLabel', wraplength=480, justify='left')
        lbl.pack(fill=tk.X, padx=8, pady=4, anchor='w')
        self.canvas.yview_moveto(1.0)

    def display_messages(self, messages, my_id: int):
        # Clear existing
        for child in self.messages_frame.winfo_children():
            child.destroy()
        for m in messages:
            try:
                is_sent = (m.idRemetente == my_id)
            except Exception:
                is_sent = False
            self._create_message_widget(m, is_sent)
        self.canvas.update_idletasks()
        self.canvas.yview_moveto(1.0)

    def _create_message_widget(self, m, is_sent: bool):
        # container frame for each message
        container = ttk.Frame(self.messages_frame, style='Card.TFrame')
        container.pack(fill=tk.X, pady=6, padx=6)

        wrap = 420
        # bubble
        bubble_style = 'Sent.TLabel' if is_sent else 'Recv.TLabel'
        bubble = ttk.Label(container, text=m.conteudo, style=bubble_style, wraplength=wrap, anchor='w', justify='left')

        ts_text = ''
        if hasattr(m, 'dataMensagem') and m.dataMensagem:
            ts = m.dataMensagem
            try:
                ts_text = ts.strftime('%Y-%m-%d %H:%M')
            except Exception:
                ts_text = str(ts)

        ts_lbl = ttk.Label(container, text=ts_text, style='Timestamp.TLabel')

        if is_sent:
            bubble.pack(side=tk.RIGHT, anchor='e', padx=(60, 6))
            ts_lbl.pack(side=tk.RIGHT, anchor='e', padx=(60, 6), pady=(2, 0))
        else:
            bubble.pack(side=tk.LEFT, anchor='w', padx=(6, 60))
            ts_lbl.pack(side=tk.LEFT, anchor='w', padx=(6, 60), pady=(2, 0))

    def load_conversation(self):
        try:
            id_sender = int(self.entry_sender.get())
            id_dest = int(self.entry_dest.get())
        except ValueError:
            messagebox.showwarning("IDs inválidos", "Informe IDs numéricos para remetente e destinatário.")
            return

        try:
            conv = ChatDAO.get_conversation(id_sender, id_dest)
            self.txt_history.configure(state='normal')
            self.txt_history.delete('1.0', tk.END)
            for m in conv:
                ts = m.dataMensagem if hasattr(m, 'dataMensagem') else dt.now()
                who = f"{m.idRemetente} ({m.tipoRemetente})"
                self.txt_history.insert(tk.END, f"[{ts}] {who}: {m.conteudo}\n")
            self.txt_history.configure(state='disabled')
        except CustomException as e:
            messagebox.showerror("Erro", f"Erro ao carregar conversa: {e}")

    def on_send(self):
        try:
            id_sender = int(self.entry_sender.get())
            id_dest = int(self.entry_dest.get())
        except ValueError:
            messagebox.showwarning("IDs inválidos", "Informe IDs numéricos para remetente e destinatário.")
            return

        conteudo = self.entry_message.get().strip()
        if not conteudo:
            return

        tipo_rem = self.combo_tipo_rem.get()
        tipo_dest = self.combo_tipo_dest.get()

        try:
            ChatDAO.send_message(id_sender, id_dest, conteudo, tipo_remetente=tipo_rem, tipo_destinatario=tipo_dest)
            # append locally and clear
            now = dt.now().strftime('%Y-%m-%d %H:%M:%S')
            self.append_history(f"[{now}] {id_sender} ({tipo_rem}): {conteudo}")
            self.entry_message.delete(0, tk.END)
        except CustomException as e:
            messagebox.showerror("Erro ao enviar", f"Erro ao enviar mensagem: {e}")


if __name__ == '__main__':
    app = UsuarioChat()
    app.mainloop()
